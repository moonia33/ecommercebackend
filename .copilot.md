# Djengo ecommerce backend (Django + Ninja)

Tikslas: sukurti pilną e‑commerce backend API (Django + Django Ninja) su PostgreSQL, integracijomis (mokėjimai + pristatymas), paieška (Meilisearch kaip atskiras Docker), CMS puslapiais, nuolaidų sistema ir pasiruošimu Svelte 5 + SvelteKit frontend’ui. Backendas gali būti labai panašiai struktūruotas, kaip django oscar. Didžiausias šiam momentui aptiktas oscar trūkumas yra variantų kombinavimas (pvz. dydis + spalva). Todėl didžiąja dalimi kuriant modelius, galima remtis oscar modelių praktika, atsižvelgiant į užduočių specifiką.

## Pagrindiniai sprendimai (šiam etapui)

- DB: PostgreSQL.
- Konfigūracija: maksimaliai per `.env` (skirtingi profiliai `dev`/`prod`).
- Rinka: multi-country kaip architektūrinis principas (valiuta, kalbos, pristatymo provideriai), bet turi būti paprastas režimas „viena šalis / viena kalba“ per nustatymus.
- Auth: klientų paskyros + galimas „guest checkout“ (galimybė išjungti per nustatymą).
- Login metodai: email+slaptažodis, OAuth (Google, Facebook) (implementacijos etapais).
- Paieška: Meilisearch kaip atskiras servisas Docker’e; jei nėra pasiekiamas – fallback į DB paiešką (ribotos galimybės, bet funkcionalu).
- Krepšelis: 1:1 (vienas aktyvus krepšelis useriui). Guest krepšelis laikomas per Django session cookie ir prisijungus yra sujungiamas į userio krepšelį.
- Marketing automatizacija: identifikaciją ir event'us laikyti „first‑party“ (pas save). Trečiosios šalys (pvz. Newsman) yra opcionalios kaip siuntimo/ESP UI, bet neturi būti kritinės identifikavimui.

## Krepšelis (1:1) ir marketing automatizacija

### Krepšelis (1:1)

- Prisijungęs useris turi vieną aktyvų krepšelį (`Cart` yra 1:1 su useriu).
- Neprisijungusiam kuriamas guest krepšelis pagal `session_key`.
- Prisijungus tame pačiame browseryje:
  - guest krepšelis sujungiamas į userio krepšelį;
  - jei userio krepšelyje jau buvo prekių – jos nepakeičiamos, o sujungimas daromas pagal variantą:
    - jei variantas sutampa abiejuose krepšeliuose – `qty` sumuojamas;
    - jei varianto nėra userio krepšelyje – eilutė perkeliama.
  - po sujungimo guest krepšelis pašalinamas.
- Po `checkout/confirm` krepšelio item'ai išvalomi (krepšelis lieka, bet tuščias) – tai leidžia išvengti „cart history spam“.

### Marketing automatizacija (be multi-cart istorijos)

- Browse/behavior tracking galima rinkti anonimiškai per „visitor_id“ (first‑party cookie) ir sieti su `session_key`.
- Kai vartotojas įveda email (pvz. per popup) ir patvirtina OTP:
  - gaunamas verified email + (pageidautina) sukuriama paskyra,
  - galima deterministiškai susieti `visitor_id/session_key` su useriu ir jo krepšeliu.
- Consent (marketing opt‑in) turi būti atskiras nuo prisijungimo/paskyros sukūrimo (checkbox + audit logas).
- Abandoned cart/browse automatizacijai rekomenduojama turėti atskirą „snapshot/event“ objektą (pvz. `CartAbandonment` / `CartSnapshot`), o ne kurti daug istorinių krepšelių.

## Technologijos

- Django
- Django Ninja
- PostgreSQL
- Redis (sesijos/cache/ratelimit/celery broker jei pasirenkama)
- Celery
- Docker + Docker Compose
- Stripe
- Siuntos: Omniva, LPExpress (Unisend), Venipak, DPD
- S3 objektų saugykla nuotraukoms (Cloudflare R2 / Hetzner S3)
- Paieška: Meilisearch (Docker)
- Email marketing automatizacija (Newsman) – integracija vėlesniame etape
- OpenAI API – vėlesniame etape

## Darbo principai

- Minimalus UX pirkimui: pirmas klausimas pristatymui – kurjeris ar paštomatas.
  - Jei paštomatas: iš karto paštomato pasirinkimas; kliento adresas užpildomas iš paštomato duomenų; opcija sąskaitai per checkbox.
  - Jei kurjeris: įprastas checkout (vardas, adresas, tel., ir t. t.).
- Viskas dokumentuojama (README ir/arba `docs/`) po reikšmingų pakeitimų.
- Struktūruotas kodas, aiškūs moduliai, našumas prioritetas.

---

# Backlog (milestone’ai su priėmimo kriterijais)

## Milestone 1 — Projekto karkasas + konfigūracija

**Tikslas:** paleidžiamas Django projektas su aiškia `.env` konfigūracija ir PostgreSQL.

Priėmimo kriterijai:

- Projektas startuoja `dev` režimu.
- Nustatymai atskirti bent į `base` ir `dev` (arba analogiškai).
- PostgreSQL prijungtas per env.
- Sukurta `health` patikra (pvz. `/api/health`).
- Paruošti saugumo nustatymai frontend’ui (CORS, CSRF strategija) ir aprašyti dokumentacijoje.

## Milestone 2 — Autentifikacija + vartotojai

**Tikslas:** klientai gali registruotis / prisijungti; guest checkout galima įjungti/išjungti.

Priėmimo kriterijai:

- Email+slaptažodis registracija ir login.
- JWT (ar kitas aiškus API auth) apsaugotiems endpoint’ams.
- Nustatymas `ALLOW_GUEST_CHECKOUT` (ar analogas) per `.env`/admin.
- OAuth integracijos suplanuotos kaip atskiri provider moduliai (Google, Facebook) – įgyvendinamos Milestone 6.

## Milestone 3 — Katalogas (produktai, variantai, kategorijos, atributai)

**Tikslas:** pilnas katalogo domenas su variantais ir admin valdymu.

Modeliai (MVP):

- Prekė
- Prekės kombinacija (variantas)
- Kategorija (medis)
- Atributai
- Gamintojai
- Tiekėjai
- Savybės (prekės charakteristika, kuri nedalyvauja variantų kombinavime, pvz. svoris, sudėtis ir pan.)
- Kolekcijos (home/side/cross/upsell)

Priėmimo kriterijai:

- Produktas turi variantus (SKU, kaina, atsargos, atributų kombinacija, savybės).
- Išspręsti, kaip bus daroma su price ir sale_price, atskiru kainų modeliu, per nuolaidų modelį ar kitaip.
- Produktas gali būti paprastas, su kombinacijomis arba virtualus.
- Gali būtų produktų, kuriems niekada netaikomos jokios nuolaidos, gal tikslinga prekės modelyje papildomai pridėti booleen lauką šiam tikslui.
- Kategorijų medis veikia (parent/children).
- Admin UI patogus vienam adminui (filtrai, inline edit jei prasminga).
- Ninja API endpoint’ai katalogui (list/detail) su paginacija.

## Milestone 4 — Krepšelis + checkout bazė

**Tikslas:** krepšelis ir checkout logika (be mokėjimų / siuntų galutinių integracijų).

Modeliai:

- Krepšelis
- Krepšelio eilutė
- Adresas
- Klientų sutikimai (naujienlaiškis, privatumo politika, taisyklės)

Priėmimo kriterijai:

- Krepšelio CRUD per API.
- Krepšelio kainos skaičiavimas (subtotal/discount/total) aiškiai apibrėžtas.
- Guest checkout leidžiamas tik jei įjungtas nustatymas.

## Milestone 5 — Pristatymas (multi-provider) + checkout UX logika

**Tikslas:** pristatymo pasirinkimas pagal tavo aprašytą trumpą pirkimo kelią.

Modeliai:

- Pristatymas (shipment) ir pristatymo pasirinkimai (metodai)

Priėmimo kriterijai:

- API leidžia pasirinkti „kurjeris“ arba „paštomatas“ kaip pirmą žingsnį.
- Paštomato atveju: paštomatų sąrašas + pasirinkimas + adresas automatiškai užpildomas.
- Integracijos etapais:
  - Omniva
  - LPExpress (Unisend)
  - Venipak
  - DPD

### DPD-first (siūlomas MVP skaidymas)

**Kodėl:** DPD API atrodo tiesesnis startui (lockers + tracking), todėl pradedam nuo jo ir pasidarom bendrą karkasą, kad vėliau LPExpress/Omniva/Venipak būtų „dar vienas provideris“.

**Domenas / būsenos:** užsakymas turi _mokėjimo būseną_ ir _pristatymo būseną_.

- Mokėjimas: lieka `Order.status` (paid/pending/cancelled).
- Pristatymas: atskiras laukas (pvz. `delivery_status`) ir (idealiai) eventų logas.
  - Minimalios būsenos (MVP): `label_created` → `shipped` → `delivered` (ir `cancelled`/`error` jei reikia).

**Carrier app'ų principas:** kiekvienas vežėjas turi atskirą Django app'ą (pvz. `dpd/`, vėliau `lpexpress/`, `omniva/`), kuriame:

- API klientas (auth + request'ai)
- normalizuotos DTO/schema helperiai
- integracijos job'ai/komandos (status sync)

**Admin lipdukai (MVP):** lipdukai formuojami iš admin (Order admin action):

- sukuria siuntą vežėjo sistemoje
- gauna `tracking_number` / siuntos numerį
- atsisiunčia label (PDF/PNG) ir pririša prie užsakymo/siuntos

**Paštomato pasirinkimas:**

- Po paštomato pasirinkimo frontas atsiunčia `locker_id`.
- Backend (DPD API) pasiima locker detales ir \_užpildo `Order.shipping\_\_ snapshot\* pagal paštomato adresą.
- Užsakyme saugom `locker_id` + `locker_name` (ir opcionuojamai raw JSON auditui).

### Įgyvendinta: DPD + Unisend (LPExpress)

#### DPD

- **Lockers API (front-end):** `GET /api/v1/dpd/lockers`
  - Parametrai: `country_code` (default `LT`), `city`, `search`, `locker_type`, `postal_code`, `limit`
  - Grąžina: `[{ id, name, lockerType, countryCode, city, street, postalCode, latitude, longitude }]`
- **Admin lipdukai:** per Order admin.
  - Vienetinis: `.../admin/checkout/order/<id>/dpd-label-a6/`
  - Masinis: admin action **„Generuoti DPD A6 lipdukus (PDF) pasirinktiems“**
- **Svarbu apie `parcelNumbers` (tracking):** DPD API gali negrąžinti `parcelNumbers` kuriant siuntą.
  - Tracking numeris (jei dar tuščias) bandomas užpildyti po label generavimo per `GET /shipments`.

#### Unisend / LPExpress

- **Terminals API (front-end):** `GET /api/v1/unisend/terminals`
  - Parametrai: `country_code` (default `LT`), `locality`, `search`, `postal_code`, `limit`
  - Grąžina: `[{ id, name, countryCode, locality, street, postalCode, latitude, longitude }]`
  - `id` yra `terminalId` iš Unisend.

- **Checkout integracija (front-end):**
  - `shipping_method` = `lpexpress` reiškia paštomato pristatymą per Unisend.
  - Tada frontas privalo siųsti `pickup_point_id` = pasirinkto terminalo `id`.
  - Backend validuoja `pickup_point_id` prieš `UnisendTerminal` DB lentelę.
  - Užsakyme saugoma:
    - `Order.pickup_point_id` = terminalId
    - `Order.pickup_point_name` = terminalo pavadinimas
    - `Order.pickup_point_raw` = terminalo raw JSON
  - Pastaba: `Order.pickup_locker` FK yra skirtas DPD (`dpd.DpdLocker`) ir Unisend atveju lieka `NULL`.

- **Admin terminalų sinchronizavimas:**
  - Admin -> **Unisend terminals** modelyje yra actions: `Sync Unisend terminals: LT/LV/EE`.

- **Admin lipdukai (Unisend):** per Order admin.
  - Vienetinis: `.../admin/checkout/order/<id>/unisend-label-10x15/`
  - Masinis: admin action **„Generuoti Unisend 10x15 lipdukus (PDF) pasirinktiems“**
  - Flow:
    - `POST /api/v2/parcel` (plan `TERMINAL`, type `T2T`)
    - `POST /api/v2/shipping/initiate`
    - `GET /api/v2/shipping/barcode/list` (tracking)
    - `GET /api/v2/sticker/pdf` (PDF)


**Kainos (paprastai):** kainas valdom admin'e (ne hardcode).

- Rate taisyklės MVP: pagal krepšelio sumos rėžius (pvz. 0–20, 20–50, 50+), atskirai `dpd_locker` ir `dpd_courier`.
- Vėliau: pagal svorį (tam reikia produkto/varianto svorio) ir pagal dimensijas.

**Dimensijos ir talpinimas į paštomatą:** reikės pridėti produktui/variantui:

- `weight_g` (svoris)
- `length_cm`, `width_cm`, `height_cm` (dėžės matmenys)

MVP taisyklė (paprasta): jei bent vienos prekės dimensijos viršija leidžiamą ribą paštomatui, `dpd_locker` metodas checkout'e neturi būti siūlomas.

**Tracking / būsenų atnaujinimas:**

- MVP: periodinis polling (management command / cron / Celery beat), kuris pagal `tracking_number` pasiima naujausią statusą ir atnaujina `delivery_status`.
- Vėliau: webhook subscription, jei DPD leidžia subscribe su `callbackurl`.

## Milestone 6 — Mokėjimai (Stripe) + užsakymo užbaigimas

**Tikslas:** patikimas apmokėjimas su webhooks, idempotency ir užsakymo būsenomis.

Modeliai:

- Užsakymas
- Užsakymo eilutė
- Mokėjimas
- Būsenos

Priėmimo kriterijai:

- Stripe checkout / payment intent flow.
- Webhook’ai atnaujina užsakymo būseną.
- Idempotency apsaugo nuo dvigubų užsakymų.

## Milestone 7 — Nuolaidos (catalog + cart)

**Tikslas:** išplėstinė nuolaidų sistema su aiškiomis prioritetų/kombinavimo taisyklėmis.

Priėmimo kriterijai:

- Catalog-based: nuolaidos produktams/kategorijoms/kolekcijoms.
- Cart-based: kuponai, minimalus krepšelis, pristatymo nuolaidos.
- Aiški taisyklė: kaip konfliktuoja/stackinasi kelios nuolaidos.

## Milestone 8 — CMS puslapiai

**Tikslas:** statiniai puslapiai (Taisyklės, Privatumo politika, kt.).

Priėmimo kriterijai:

- CRUD admin’e.
- API puslapių gavimui pagal slug.
- Paruošta vieta i18n (žr. „Atviri klausimai“).

## Milestone 9 — Paieška (Meilisearch) + fallback

**Tikslas:** greita paieška per Meilisearch, bet sistema veikia ir be jo.

Priėmimo kriterijai:

- Docker servisas Meilisearch.
- Indeksavimo job’as (Celery) + atnaujinimas pasikeitus produktams.
- Jei Meilisearch nepasiekiamas: fallback į DB `icontains`/`trigram` (minimaliai).

## Milestone 10 — Importai + vertimai + automatizacijos

**Tikslas:** produktų importai ir vertimų pipeline (su galimu OpenAI pagalbininku).

Priėmimo kriterijai:

- CSV/XLSX/XML importas (MVP).
- Vertimai bent 1→N kalbų (architektūra).
- Celery užduotys ilgiems darbams.

---

# Atviri klausimai (apsispręsti prieš kodą)

1. i18n strategija: vienas backend’as su `Language`/`Country` modeliais ir vertimų lentelėmis, ar atskiri backend’ai pagal šalis/kabas?
2. OAuth: ar naudojam „allauth“ tipo sprendimą, ar rašom plonesnį OAuth tik token’ų išdavimui API?
3. Multi-currency: ar pradiniame etape darom tik EUR, bet architektūriškai paliekam vietą (Currency modelis, price field’ai)?
4. Kainodara: ar laikom `price` + `sale_price` ant varianto, ar darom atskirą `Price` modelį (pvz. pagal šalį/valiutą/kanalą), o nuolaidas skaičiuojam per taisykles?
5. Nuolaidų išimtys: ar darom `exclude_from_discounts` boolean ant produkto/varianto (ir ar jis turi perrašyti visas kampanijas)?
6. Importai: MVP importo formatai – CSV + XLSX + XML (patvirtinti prioriteto tvarka) ir ar reikia supplier feed’ų periodinio sinchronizavimo.
7. Oscar inspiracija: kokį lygį kopijuojam (domenų moduliai ir naming), o ko nedarom (Oscar variantų kombinavimo apribojimai) – kad neprisirištume per stipriai.
